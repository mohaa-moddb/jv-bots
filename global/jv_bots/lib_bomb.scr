/**
Multiplayer Bot script for MoH:AA obj
=============================================
by jv_map
version 1.1
---------------------------------------------
Copyright (c) 2002-2003 Jeroen Vrijkorte
All rights reserved.
---------------------------------------------
Distribution is allowed provided all subsequent 
conditions are met:

1. Commercial use is prohibited.

2. The above copyright notice and this permission notice shall
be included in all copies or substantial portions of the file.

3. If you have made modifications to the original files you must
cause the modified files to carry prominent notices stating
that you changed the files.

COPYRIGHT HOLDERS WILL NOT BE LIABLE FOR ANY DIRECT, INDIRECT, 
SPECIAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF ANY USE OF THE 
SOFTWARE OR DOCUMENTATION.
---------------------------------------------
jv_map@planetmedalofhonor.com
http://www.planetmedal.com/freebrief
---------------------------------------------
*/

/**
---------------------------------------------
Bomb Support Threads
---------------------------------------------
*/

/**
Setup the bombs.
*/
setup:
	if($bombnode)
	{
		if(level.jvbot_bombs == NIL)
			level.jvbot_bombs = 0
		
		for(local.i = 1; local.i <= $bombcamp.size; local.i++)
			$bombcamp[local.i].users = 0
			
		for(local.i = 1; local.i <= $bombnode.size; local.i++)
		{
			local.node = $bombnode[local.i]
			local.bomb = local.node.target

			if(local.bomb.weight == NIL)
				local.bomb.weight = 1
			
			level.jvbot_bombs++ // for desyncing
			
			local.bomb thread bombdefendcontrol local.node
			local.bomb thread bombattackcontrol local.node
		}
	}
end

presetup:
	// one time setup
	if !(level.jvbot_bombpresetup)
	{
		waitthread level.jvbot_main_script::addroute bombnode 1
		waitthread level.jvbot_main_script::addroute bombcamp 1
		level.jvbot_bombpresetup = 1
	}
end

shutdown:
	for(local.i = 1; local.i <= $bombnode.size; local.i++)
	{
		local.node = $bombnode[local.i]
		local.bomb = local.node.target
		if(local.bomb.exploded == 1 && level.jvbot_verbose)
			println "INFO[lib_bomb::shutdown]: Bomb: " local.bomb " has already exploded."
		else
		{
			if(level.jvbot_verbose)
				println "INFO[lib_bomb::shutdown]: Shutting down controllers for bomb: " local.bomb
			local.bomb.shutdown = 1
			local.time = 0
			while(local.bomb.shutdown == 1 && local.time <= 5)
			{
				wait 0.5
				local.time += 0.5
			}
			if(local.bomb.shutdown == 0)
			{
				if(level.jvbot_verbose)
					println "INFO[lib_bomb::shutdown]: Bomb controllers for bomb: " local.bomb " succesfully ended."
			}
			else
				println "ERROR[lib_bomb::shutdown]: Failed shutdown for bomb controller (bomb: " local.bomb ")."
		}
	}
end

getbots local.task local.parm1:
	// check all bots for this task and parm[1]
	local.j = 0
	for(local.i = 1; local.i <= level.botlastid; local.i++)
	{
		local.bot = level.actualbots[local.i]
		if(isAlive local.bot && local.bot.task == local.task && local.bot.parm[1] == local.parm1)
		{
			local.j++
			local.out[local.j] = local.bot	
		}
	}
end local.out

bombdefendcontrol local.bombnode:
	// waitframes for de-syncing
	for(local.i = 1; local.i <= level.jvbot_bombs; local.i++)
		waitframe
	
	local.team = self.defuseteam
	while(self.exploded != 1 && self.shutdown != 1)
	{
		local.bots = waitthread getbots defendbomb local.bombnode
		self.bots[local.team] = local.bots.size
		// clear all bomb tasks and set new ones
		if(local.bots.size > 0)
		{
			for(local.i = 1; local.i <= local.bots.size; local.i++)
				local.bots[local.i].newsubtask = void
			
			if(self.beingset == 1)
			{
				// all out attack on the planter
				for(local.i = 1; local.i <= local.bots.size; local.i++)
					local.bots[local.i].newsubtask = activate
			}
			else
			{
				if(self.ticking == 1)// && self.hasantiplanter != 1)
				{
					// need to defuse the bomb, so find a suitable bot
					local.antiplanter = self waitthread getbestbot local.bots self defuse
					if(local.antiplanter != NIL)
					{
						local.antiplanter.newsubtask = defuse
						self.antiplanter = local.antiplanter
					
						// other bots should defend the defuser;
						// defend the defuser if closer to him than to the bomb
						// vice versa otherwise
						local.remainingbots = waitthread getnotaskbots local.bots
						local.diffvector = 2 * local.antiplanter.origin - self.origin
						for(local.i = 1; local.i <= local.remainingbots.size; local.i++)
						{
							local.bot = local.remainingbots[local.i]
							if(vector_within local.bot.origin local.antiplanter.origin 1024)
							{
								if(vector_closer local.diffvector self.origin local.bot.origin || local.bot.subtask == escort)
									local.bot.newsubtask = escort
							}
						}
						if(self.critical)
							// disable enemy searching
							local.antiplanter.newsubtask = ignoredefuse
					}
				}
				// setup the campers
				local.campers = waitthread getnotaskbots local.bots
				for(local.i = 1; local.i <= local.campers.size; local.i++)
				{
					local.bot = local.campers[local.i]
					local.bot.newsubtask = camp
				}
			}
		}
		// cast tasks
		for(local.i = 1; local.i <= local.bots.size; local.i++)
			local.bots[local.i].subtask = local.bots[local.i].newsubtask		
		
		waitframe
		wait level.jvbot_loopdelay
	}
	// ignore this bomb
	//local.bots = self waitthread cleanuparray self.rawbots[local.team]
	//for(local.i = 1; local.i <= local.bots.size; local.i++)
	//	local.bots[local.i].task = idle
	
	self.shutdown = 0
end

bombattackcontrol local.bombnode:
	// extra waitframe for more de-syncing
	for(local.i = 1; local.i <= level.jvbot_bombs; local.i++)
		waitframe
	waitframe
	
	local.team = self.plantteam
	while(self.exploded != 1 && self.shutdown != 1)
	{
		// create the bot array
		local.bots = waitthread getbots attackbomb local.bombnode // new :D
		self.bots[local.team] = local.bots.size
		
		// clear all bomb tasks and set new ones
		if(local.bots.size > 0)
		{
			for(local.i = 1; local.i <= local.bots.size; local.i++)
				local.bots[local.i].newsubtask = void			

			if(self.beingdefused == 1)
			{
				// all out attack on the defuser
				for(local.i = 1; local.i <= local.bots.size; local.i++)
					local.bots[local.i].newsubtask = activate
			}
			else
			{
				if(self.ticking != 1) // && self.hasplanter != 1) // test!
				{
					// need to plant a bomb, so find a suitable bot
					local.planter = self waitthread getbestbot local.bots self plant
					if(local.planter != NIL)
					{
						local.planter.newsubtask = plant
						self.planter = local.planter
					
						// other bots should defend the planter;
						// defend the planter if closer to him than to the bomb
						// vice versa otherwise
						local.remainingbots = waitthread getnotaskbots local.bots
						local.diffvector = 2 * local.planter.origin - self.origin
						for(local.i = 1; local.i <= local.remainingbots.size; local.i++)
						{
							local.bot = local.remainingbots[local.i]
							if(vector_within local.bot.origin local.planter.origin 1024)
							{
								if(vector_closer local.diffvector self.origin local.bot.origin || local.bot.subtask == escort)
									local.bot.newsubtask = escort
							}
						}
					}
				}
				// setup the campers
				local.campers = waitthread getnotaskbots local.bots
				for(local.i = 1; local.i <= local.campers.size; local.i++)
				{
					local.bot = local.campers[local.i]
					local.bot.newsubtask = camp
				}
			}
		}
		// cast tasks
		for(local.i = 1; local.i <= local.bots.size; local.i++)
			local.bots[local.i].subtask = local.bots[local.i].newsubtask	
			
		waitframe
		wait level.jvbot_loopdelay
	}
	// ignore this bomb
	//local.bots = self waitthread cleanuparray self.rawbots[local.team]
	//for(local.i = 1; local.i <= local.bots.size; local.i++)
	//	local.bots[local.i].task = idle
	
	self.shutdown = 0
end

getnotaskbots local.bots:
	local.j = 1
	for(local.i = 1; local.i <= local.bots.size; local.i++)
	{
		local.bot = local.bots[local.i]
		if(local.bot.newsubtask == void)
		{
			local.notaskbots[local.j] = local.bot
			local.j++
		}
	}
end local.notaskbots

getbestbot local.bots local.bomb local.subtask:
	if(local.bomb == NIL)
		local.bomb = self
	local.highest = 0.0
	for(local.i = 1; local.i <= local.bots.size; local.i++)
	{
		local.bot = local.bots[local.i]
		
		local.distance = vector_length (local.bot.origin - local.bomb.origin)
		local.dist_weight = 1024.0 / (local.distance + 1024)
		
		local.z_vector = abs((local.bot.origin - local.bomb.origin)[2])
		local.z_weight = 128.0 / (local.z_vector + 128) // more important than regular distance
		
		if(local.bot.enemy == NULL)
			local.state_weight = 1
		else
			local.state_weight = 0.5
		
		local.health_weight = local.bot.health / 100.0
		
		if(local.bot.subtask == local.subtask)
			local.bonus = 1
		else
			local.bonus = 0
	
		local.priority = 0.5 * (local.dist_weight + local.z_weight) + 0.5 * local.state_weight + 0.5 * local.health_weight + 2 * local.bonus

		if(local.priority > local.highest)
		{
			local.bestbot = local.bot
			local.highest = local.priority
		}
	}
end local.bestbot

breakrun:
	// break move
	local.newtask = self.task
	self.task = idle
	self.notask = 1
	while(isAlive self && self.go_to == 1)
	{
		wait level.jvbot_loopdelay
		waitframe					
	}
	if(isAlive self)
	{
		self.task = local.newtask
		self.notask = 0	
	}
end

camp local.bombnode:
	local.bomb = local.bombnode.target
	local.node = self waitthread getbestcampnode local.bomb.campset
	if(local.node == NIL)
	{
		println "ERROR[lib_bomb::camp]: Couldn't find a camp node!"
		wait 0.5
		end
	}
	local.node.users++
	local.task = self.task
	local.subtask = self.subtask
	
	// make sure we're not moving to yet
	while(isAlive self && self.go_to == 1 && self.task == local.task && self.parm[1] == local.bombnode && self.subtask == local.subtask)
	{
		wait level.jvbot_loopdelay
		waitframe
	}
	if(isAlive self && self.go_to != 1 && self.task == local.task && self.parm[1] == local.bombnode && self.subtask == local.subtask)
	{
		self thread level.jvbot_main_script::action_go_to_routed local.node (64 * local.node.users)
		while(isAlive self && self.go_to == 1 && self.task == local.task && self.parm[1] == local.bombnode && self.subtask == local.subtask)
		{
			wait level.jvbot_loopdelay
			waitframe
		}
		if(isAlive self)
		{
			if(self.go_to == 0)
			{
				// reached destination
				self resetleash
				self.fixedleash = 1
				local.movecloser = self.movecloser
				self.movecloser = 0
				if(local.node.target != "")
				{
					self turnto local.node.target
					local.height = local.node.target.origin[2] - self.origin[2]
				}
				else
				{
					self turnto local.bomb
					local.height = 80
				}

				self waittill turndone
				
				local.forwardvec = self.forwardvector * 348
				local.leftvec = self.leftvector * 256
				local.lookvec = local.forwardvec + self.origin
				local.lookvec[2] += local.height
				local.lookent = spawn script_origin origin local.lookvec
				local.tmpent = spawn script_origin origin local.lookvec
				local.dir = 0
				self aimat local.lookent
				
				wait 0.3
				local.time = 0.3
				local.indanger = 0
			
				while(isAlive self && local.indanger == 0 && self.task == local.task && self.subtask == local.subtask && self.parm[1] == local.bombnode)
				{
					local.health = self.health
					if(local.time >= 1.0)
					{
						local.predir = local.dir
						if(local.dir >= 1)
							local.dir--
						else if(local.dir <= -1)
							local.dir++
						else
						{
							if(randomint 2 == 0)
								local.dir++
							else
								local.dir--
						}
						local.lookvec = local.forwardvec + (vector_scale local.leftvec local.dir) + self.origin
						local.lookvec[2] += local.height
						local.tmpent.origin = local.lookvec
						if(self cansee local.tmpent)
							local.lookent.origin = local.lookvec
						local.time = 0
					}
					wait 0.05 // frame
					wait level.jvbot_loopdelay
					local.time += level.jvbot_loopdelay
					local.time += 0.05
					if(isAlive self && self.health < local.health)
					{
						self aimat self.fact.attacker
						wait 1
						self aimat NULL	
					}
					if(isAlive self)
						local.indanger = self waitthread campdanger local.bomb
				}
				if(isAlive self)
				{
					self.fixedleash = 0
					self.movecloser = local.movecloser
					self aimat NULL
					if(local.indanger == 1 && self.subtask != activate)
					{
						// just get the hell out of there :)
						self.notask = 1
						self.subtask = flee
						// try to find a campnode outside the bomb's radius
						local.newnode = self waitthread getsafecampnode local.bomb
						// run to this campnode, now!
						if(local.newnode)
						{
							local.mindist = self.mindist
							local.leash = self.leash
							self.mindist = 0
							self.leash = 0
							self runto local.newnode
							self waittill movedone
							if(isAlive self)
							{
								self.leash = local.leash
								self.mindist = local.mindist
								// wait till the bomb has blown
								while(local.bomb.ticking)
									wait 0.2
								if(isAlive self)
								{
									self.task = idle
									self.notask = 0
								}
							}
						}
						else
						{
							// self pray :)
							self.notask = 1
							while(local.bomb.ticking)
								wait 0.2
							if(isAlive self)
							{
								self.task = idle
								self.notask = 0
							}
						}
					}
				}
				local.lookent delete
				local.tmpent delete
			}
			else
				self waitthread breakrun
		}
	}
	local.node.users--
end

campdanger local.bomb:
	// check if the guy is within explosion radius of a critical bomb
	if(local.bomb.critical)
	{
		if(vector_within self.origin local.bomb.origin local.bomb.explosion_radius && sighttrace (self.origin + (0 0 48)) local.bomb.origin 2)
			end 1	
	}
end 0

getsafecampnode local.bomb:
	// returns the nearest campnode outside the bomb's radius
	local.num = 0
	local.set = local.bomb.campset
	for(local.i = 1; local.i <= $bombcamp.size; local.i++)
	{
		local.node = $bombcamp[local.i]
		if(local.node.set == local.set)
		{
			local.num++
			local.setnode[local.num] = local.node
		}
	}
	// find safe nodes
	local.j = 0
	for(local.i = 1; local.i <= local.num; local.i++)
	{
		local.node = local.setnode[local.i]
		if (!vector_within local.node.origin local.bomb.origin local.bomb.explosion_radius || !(sighttrace (local.node.origin  + (0 0 48)) local.bomb.origin 2))
		{
			local.j++	
			local.safenode[local.j] = local.node
		}
	}
	// return the nearest safe node
	local.highest = 0
	local.nearest = NULL
	for(local.i = 1; local.i <= local.j; local.i++)
	{
		local.node = local.safenode[local.i]
		// our location is not safe, whereas the safenode is safe
		// thus distance will never be zero
		local.inv_dist = 1.0 / (vector_length (self.origin - local.node.origin))
		if(local.inv_dist > local.highest)
		{
			local.highest = local.inv_dist
			local.nearest = local.node	
		}
	}
end local.nearest

getbestcampnode local.set:
	local.num = 1
	for(local.i = 1; local.i <= $bombcamp.size; local.i++)
	{
		local.node = $bombcamp[local.i]
		if(local.node.set == local.set)
		{
			local.setnode[local.num] = local.node
			local.num++
		}
	}
	local.highest = 0
	local.j = 0
	for(local.i = 1; local.i <= local.setnode.size; local.i++)
	{
		local.node = local.setnode[local.i]

		if !((self.dmteam == allies && local.node.noallies == 1) || (self.dmteam == axis && local.node.noaxis == 1))
		{
			local.j++
			
			local.distance = vector_length (self.origin - local.node.origin)
			local.dist_weight = 1024.0 / (local.distance + 1024)
		
			local.z_vector = abs((self.origin - local.node.origin)[2])
			local.z_weight = 128.0 / (local.z_vector + 128) // more important than regular distance
		
			local.user_weight = 1.0 / (10 * local.node.users + 1)
			local.ran_bonus = (0.5 + randomfloat 1)

			local.priority = local.dist_weight * local.z_weight * local.user_weight * local.ran_bonus
		
			if(local.priority > local.highest)
			{
				local.highest = local.priority
				local.bestnode = local.node
			}
		}
	}
	if(local.bestnode == NIL)
	{
		println "ERROR[lib_bomb::getbestcampnode]: Campnode shortage for campset: #" local.set
		local.num = randomint local.setnode.size + 1
		local.bestnode = local.setnode[local.num]
	}
end local.bestnode

activate local.bombnode:
	local.subtask = self.subtask
	local.task = self.task
	
	// make sure we're not going to yet
	while(isAlive self && self.go_to == 1 && self.task == local.task && self.parm[1] == local.bombnode && self.subtask == local.subtask)
	{
		wait level.jvbot_loopdelay
		waitframe
	}
	if(isAlive self && self.go_to == 0 && self.task == local.task && self.parm[1] == local.bombnode && self.subtask == local.subtask)
	{
		self thread level.jvbot_main_script::action_go_to_routed local.bombnode 512
		while(isAlive self && self.go_to == 1 && self.task == local.task && self.parm[1] == local.bombnode && self.subtask == local.subtask)
		{
			wait level.jvbot_loopdelay
			waitframe
		}
		if(isAlive self)
			self waitthread breakrun
	}
end

escort local.destination:
	if(isAlive local.destination)
	{
		local.task = self.task
		local.subtask = self.subtask
		local.dest_task = local.destination.task
		local.dest_subtask = local.destination.subtask
		local.dest_point = spawn script_origin
		local.dest_point.origin = local.destination.origin - local.destination.forwardvector * 128
		local.leash = self.leash
		local.mindist = self.mindist
		self.mindist = 0
		self.leash = 512
		local.movecloser = self.movecloser
		self.movecloser = 0
		self.movedonerange = 512
		self runto local.dest_point
		self tether local.dest_point
		while(isAlive self && self.task == local.task && self.subtask == local.subtask && isAlive local.destination && local.dest_task == local.destination.task && local.dest_subtask == local.destination.subtask)
		{
			if(local.destination.enemy)
			{
				self favoriteenemy local.destination.enemy
				self tether local.destination.enemy
				wait 1
			}
			else
			{
				self tether local.dest_point
				local.dest_point.origin = local.destination.origin - local.destination.forwardvector * 128
				waitframe
			}
		}
		if(isAlive self)
		{
			self runto NULL
			self resetleash
			self.leash = local.leash
			self.mindist = local.mindist
			self.movecloser = local.movecloser
		}
		local.dest_point remove
	}
	else
		self.subtask = void
end

bombaction local.bomb:
	self.avoidplayer = 1
	self turnto local.bomb
	wait 0.2
	self lookat local.bomb
	wait 0.2
	if(local.bomb.origin[2] < (self.origin[2] + 32) && local.bomb.nocrouch != 1)
		self waitexec global/crouch.scr
	self lookat NULL
end