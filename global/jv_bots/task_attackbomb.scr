/**
Multiplayer Bot script for MoH:AA obj
=============================================
by jv_map
version 1.1
---------------------------------------------
Copyright (c) 2002-2003 Jeroen Vrijkorte
All rights reserved.
---------------------------------------------
Distribution is allowed provided all subsequent 
conditions are met:

1. Commercial use is prohibited.

2. The above copyright notice and this permission notice shall
be included in all copies or substantial portions of the file.

3. If you have made modifications to the original files you must
cause the modified files to carry prominent notices stating
that you changed the files.

COPYRIGHT HOLDERS WILL NOT BE LIABLE FOR ANY DIRECT, INDIRECT, 
SPECIAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF ANY USE OF THE 
SOFTWARE OR DOCUMENTATION.
---------------------------------------------
jv_map@planetmedalofhonor.com
http://www.planetmedal.com/freebrief
---------------------------------------------
*/

/**
---------------------------------------------
Bomb Planting Behaviour
---------------------------------------------
*/

setup:
	waitthread level.jvbot_modscript[libbomb]::presetup
end

/**
Priority factors:
	-distance
	-number of bots near bomb
	-bomb #weight value
This task can be performed in-combat.
*/
getpriority:
	if($bombnode.size > 0)
	{
		local.bestscore = -1
		for(local.i = 1; local.i <= $bombnode.size; local.i++)
		{
			local.node = $bombnode[local.i]
			local.score = waitthread evaluate local.node
			if(local.score > local.bestscore)
			{
				local.best_node = local.node
				local.bestscore = local.score
			}
		}
		local.priority = local.bestscore
		local.parm1 = local.best_node
	}
	else
		local.priority = -1
	
	local.output = local.priority::local.parm1
end local.output

evaluate local.parm local.onlyeval:
	if(self.enemy == NULL)
		local.stateweight = 1
	else
		local.stateweight = 0.5
	local.score = 0
	local.bombnode = local.parm[1]
	local.bomb = local.bombnode.target
	if(local.bomb.plantteam == self.dmteam && local.bomb.exploded != 1)
	{
		if(local.bomb.ticking == 1)
			local.weight = 12
		else if(local.bomb.beingset == 1)
			local.weight = 6
		else
			local.weight = 1

		local.campers = local.bomb.bots[self.dmteam]
		if(local.campers < 0)
			local.campers = 0
		local.distance = vector_length (self.origin - local.bombnode.origin)
		local.campweight = 3.0 / (local.campers + 3)
		local.score = 0.1 * (1024.0 / (local.distance + 1024)) + local.campweight * local.stateweight * local.bomb.weight * local.weight
	}
end local.score

/**
One bot plants the bomb, others try to protect him.
*/
action:
	local.bombnode = self.parm[1]
	local.bomb = local.bombnode.target
	if(local.bomb == "")
	{
		self.task = idle
		end
	}
	local.team = self.dmteam
	//local.arrayid = local.bomb.rawbots[local.team].size + 1
	//if(local.arrayid < 1)
	//	local.arrayid = 1
	//local.bomb.rawbots[local.team][local.arrayid] = self
	local.voids = 0
	while(isAlive self && self.task == "attackbomb" && self.parm[1] == local.bombnode)
	{
		switch(self.subtask)
		{
			plant:
				local.voids = 0
				self thread level.jvbot_modscript[debug]::debugmodifylight 128 blue
				self thread level.jvbot_modscript[debug]::debugmodifylight 128 red
				self waitthread plant local.bombnode
				if(isAlive self)
				{
					self thread level.jvbot_modscript[debug]::debugmodifylight -128 blue
					self thread level.jvbot_modscript[debug]::debugmodifylight -128 red
				}
				break
			escort:
				local.voids = 0
				self thread level.jvbot_modscript[debug]::debugmodifylight 128 blue
				self thread level.jvbot_modscript[debug]::debugmodifylight 128 green
				self waitthread level.jvbot_modscript[libbomb]::escort local.bomb.planter
				if(isAlive self)
				{
					self thread level.jvbot_modscript[debug]::debugmodifylight -128 blue
					self thread level.jvbot_modscript[debug]::debugmodifylight -128 green
				}
				break
			activate:
				// attack bomb defuser
				local.voids = 0
				self thread level.jvbot_modscript[debug]::debugmodifylight 256 red
				while(isAlive self && self.task == "attackbomb" && self.parm[1] == local.bombnode && self.subtask == activate)
				{
					if !(self cansee local.bomb 90 512)
						self waitthread level.jvbot_modscript[libbomb]::activate local.bombnode
					
					waitframe
					wait level.jvbot_loopdelay
				}
				if(isAlive self)
					self thread level.jvbot_modscript[debug]::debugmodifylight -256 red
				break
			camp:
				local.voids = 0
				self thread level.jvbot_modscript[debug]::debugmodifylight 128 green
				self waitthread level.jvbot_modscript[libbomb]::camp local.bombnode
				if(isAlive self)
					self thread level.jvbot_modscript[debug]::debugmodifylight -128 green
				break
			default: // void
				local.voids++
				waitframe
				wait level.jvbot_loopdelay
				//if(local.voids >= 3)
					// something's gone wrong
				//	self.task = idle
		}
	}
end

plant local.bombnode:
	local.subtask = self.subtask
	local.bomb = local.bombnode.target
	// make sure we're not going to yet
	while(isAlive self && self.go_to == 1 && self.task == "attackbomb" && self.parm[1] == local.bombnode && self.subtask == local.subtask)
	{
		wait level.jvbot_loopdelay
		waitframe
	}
	
	if(isAlive self && self.go_to != 1 && self.task == "attackbomb" && self.parm[1] == local.bombnode && self.subtask == local.subtask)
	{
		self.nodeviate = 1
		self thread level.jvbot_main_script::action_go_to_routed local.bombnode 348
		while(isAlive self && self.go_to == 1 && self.task == "attackbomb" && self.parm[1] == local.bombnode && self.subtask == local.subtask)
		{
			wait level.jvbot_loopdelay
			waitframe
		}
		if(isAlive self)
		{
			self.nodeviate  = 0
			if(self.go_to == 0 && self.task == "attackbomb" && self.parm[1] == local.bombnode && self.subtask == local.subtask)
			{
				// reached destination
				// point of no return
				local.bomb.hasplanter = 1
				self thread level.jvbot_modscript[debug]::debugmodifylight 256 red
				self waitthread doplant local.bombnode
				self thread level.jvbot_modscript[debug]::debugmodifylight -256 red
				local.bomb.hasplanter = 0
			}
			else
				self waitthread level.jvbot_modscript[libbomb]::breakrun
		}
	}
end

doplant local.bombnode:
	self.notask = 1
	local.bomb = local.bombnode.target
	self runto NULL
	self waitthread level.jvbot_main_script::action_go_to local.bombnode 64
	if(isAlive self)
	{
		self.avoidplayer = 0
		self waitthread level.jvbot_modscript[libbomb]::bombaction local.bomb
		thread abort
		local.thread = parm.previousthread
		local.bomb waitthread global/jv_obj_dm.scr::bomb_set self
		if(local.thread)
			local.thread end
		if(isAlive self)
		{
			// bomb planted - good job :) / or aborted
			if(self.position == crouch)
				self waitexec global/stand.scr
				
			self.avoidplayer = 1
			self.notask = 0
			if(randomint 2 == 1 && local.bomb.ticking == 1 && (waitthread level.jvbot_modscript[spawnhandler]::getteammembers self.dmteam 1 0) > 0)
				self thread saycoverbomb
		}
	}
end

abort:
	self waittill pain
	self aimat self.fact.attacker
	self.useheld = 0
	wait 0.5
	self aimat NULL
end

/**
Notify squad mates the bomb needs to be protected.
*/
saycoverbomb:
	wait (randomfloat 2 + 1)
	if(isAlive self)
		self waitthread level.jvbot_main_script::say ae // hold this position
end