/**
Multiplayer Bot Attack Animation for MoH:AA
=============================================
by jv_map
version 1.1
---------------------------------------------
Copyright (c) 2002-2003 Jeroen Vrijkorte
All rights reserved.
---------------------------------------------
Distribution is allowed provided all subsequent 
conditions are met:

1. Commercial use is prohibited.

2. The above copyright notice and this permission notice shall
be included in all copies or substantial portions of the file.

3. If you have made modifications to the original files you must
cause the modified files to carry prominent notices stating
that you changed the files.

COPYRIGHT HOLDERS WILL NOT BE LIABLE FOR ANY DIRECT, INDIRECT, 
SPECIAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF ANY USE OF THE 
SOFTWARE OR DOCUMENTATION.
---------------------------------------------
jv_map@planetmedalofhonor.com
http://www.planetmedal.com/freebrief
---------------------------------------------
*/

/**
---------------------------------------------
Modified Attack Handler Script

Prevents proning and increases bot aggresiveness.
---------------------------------------------
*/

AttackMain:
	// boonDebug sets whether or not to print debug messages from this script.
	level.boonDebug = 0

	thread DPrintln "Attack main called"
	waitexec anim/smoking.scr::SmokeRemoveCigarette
	waitexec anim/reload.scr::ReloadInit
	self weaponcommand mainhand attachtohand mainhand

	//defines
	self.shortrange = 150
	self.mediumrange = 650
	self.pronedistance = 850

	self.dist_walkforward = 110
	self.dist_walkbackward = 90
	self.dist_walkleft = 80
	self.dist_walkright = 80
	self.dist_dodgeleft = 70
	self.dist_dodgeright = 70
	self.dist_crouchleft = 15
	self.dist_crouchright = 15
	self.dist_prone_roll_left = 30
	self.dist_prone_roll_right = 30

	//attack parameters default value - set based on distance below

	//percent chance of dodging (while player is not aiming at me)
	self.dodgepct = 25 // 50
	//percent chance of moving forward
	self.aggresiveness = 75
	//percent chance of backing away
	self.backawaypct = 25
	//percent chance of doing a strafe during dodge - should really be name self.strafedodgepct
	self.strafepct = 75
	//percent chance of shooting while dodging - should really be named self.dodgeshootpct
	self.shootpct = 90
	//boolean whether to dodege when player is aiming at me
	self.aimdodge = 0
	//amount of time to spend aiming before shooting
	self.aimtime = 0.25

	// set a weapon num so we can use integer comparison in the future
	if(self.weaponnum == NIL)
	{
		switch(self.weapon)
		{
			case "m1 garand":
				self.weaponnum = 1
				break
			case "mauser kar 98k":
				self.weaponnum = 2
				break
			case "springfield '03 sniper":
				self.weaponnum = 3
				break
			case "mauser kar 98d sniper":
				self.weaponnum = 4
				break
			case "thompson":
				self.weaponnum = 5
				break
			case "mp40":
				self.weaponnum = 6
				break
			case "bar":
				self.weaponnum = 7
				break
			case "stg44":
				self.weaponnum = 8
				break
			case "shotgun":
				self.weaponnum = 9
				break
			default:
				self.weaponnum = 0
		}
	}

	self.enemyaimingme = 0
	self.collideresult = 0
	self.movedtointervaldir = 0
	self.movingtointervaldir = 0
	self.needreload = 0
	self.lastmovement = "none"
	group.subthread = NULL

	while (1)
	{
		waitexec anim/default_inithandler.scr

		//get distance
		local.distance = self.distancetoenemy
		if (local.distance > self.mediumrange)
		{
			//long range attack
			waitexec anim/jv_bots/attack.scr::AttackLongRangeStart
		}
		else if (local.distance > self.shortrange)
		{
			//medium range attack
			waitexec anim/jv_bots/attack.scr::AttackMediumRangeStart
		}
		else
		{
			//we must be in short range
			waitexec anim/jv_bots/attack.scr::AttackShortRangeStart
		}

		waitexec anim/jv_bots/attack.scr::AttackDeleteSubThread
	
	}
	//level.attackhandlers--
end

//=============================================================
//=============================================================
AttackDeleteSubThread:
	//println ":: call: attackdeletesubthread"
	if (group.subthread != NIL)
	{
		if (group.subthread != NULL)
		{
			group.subthread delete
			//println ":: attack subthread deleted."
		}
	}
end

//=============================================================
//=============================================================
AttackShortRangeStart:
	//println ":: call: attackshortrangestart"
	
	if(self.movingcloser == 1)
	{
		// stop running towards
		self resetleash
		self.movingcloser = 0
	}
	local.skillbonus = level.jvbot_skill * 25 - 50
	local.aimtimebonus = (3 - (level.jvbot_skill - 1)) / 3.0 + 0.33
	
	switch(self.weaponnum)
	{
		case 1:
		case 2:
			self.dodgepct = 25
			self.aggresiveness = 50
			self.backawaypct = 50
			self.strafepct = 100
			self.shootpct = 100
			self.aimdodge = 1
			self.aimtime = 0.10 * local.aimtimebonus
			self.accuracy = 60 + local.skillbonus
			break
		case 3:
		case 4:
			self.dodgepct = 10
			self.aggresiveness = 0
			self.backawaypct = 90
			self.strafepct = 25
			self.shootpct = 100
			self.aimdodge = 1
			self.aimtime = 0.30 * local.aimtimebonus
			self.accuracy = 40 + local.skillbonus
			break
		case 5:
		case 6:
			self.dodgepct = 25
			self.aggresiveness = 25
			self.backawaypct = 0
			self.strafepct = 25
			self.shootpct = 100
			self.aimdodge = 1
			self.aimtime = 0
			self.accuracy = 80 + local.skillbonus
			self.movecloser = 1
			break
		case 7:
			self.dodgepct = 25
			self.aggresiveness = 0
			self.backawaypct = 50
			self.strafepct = 50
			self.shootpct = 100
			self.aimdodge = 1
			self.aimtime = 0.10 * local.aimtimebonus
			self.accuracy = 60 + local.skillbonus
		case 8:
			self.dodgepct = 25
			self.aggresiveness = 0
			self.backawaypct = 25
			self.strafepct = 100
			self.shootpct = 100
			self.aimdodge = 0
			self.aimtime = 0
			self.accuracy = 70 + local.skillbonus
			self.movecloser = 1
			break
		case 9:
			self.dodgepct = 25
			self.aggresiveness = 50
			self.backawaypct = 0
			self.strafepct = 50
			self.shootpct = 100
			self.aimdodge = 0
			self.aimtime = 0
			self.accuracy = 40 + local.skillbonus
			self.movecloser = 1
			break
		default:
			self.dodgepct = 25
			self.aggresiveness = 50
			self.backawaypct = 50
			self.strafepct = 50
			self.shootpct = 100
			self.aimdodge = 1
			self.aimtime = 0.10 * local.aimtimebonus
			self.accuracy = 50 + local.skillbonus
	}
	self.instandshoot = 0
	self.movedtointervaldir = 0
	self.movingtointervaldir = 0
	self.inreload = 0

	thread AttackMediumRange
	local.mythread = parm.previousthread

	while(1)
	{
		// this wait moved from bottom of loop to avoid running the same thread twice in a frame.
		waitframe

		local.distance = self.distancetoenemy
		if (local.distance > self.shortrange && self.inreload == 0 && self.movingtointervaldir == 0)
		{
			break
		}

		if (local.distance < self.reallyshortrange && self.weapongroup != bazooka && self.inreload == 0 && self.movingtointervaldir == 0)
		{
			self.instandshoot = 0
			
			local.mythread delete
			waitexec anim/jv_bots/attack.scr::AttackDeleteSubThread

			waitexec anim/jv_bots/attack.scr::AttackReallyShortRange
			thread AttackMediumRange
			local.mythread = parm.previousthread
		}
	}

	local.mythread delete
	waitexec anim/jv_bots/attack.scr::AttackDeleteSubThread
end

//=============================================================
//=============================================================
AttackMediumRangeStart:
	thread DPrintln "Calling medium range start"
	
	if(self.movingcloser == 1)
	{
		// stop running towards
		self resetleash
		self.movingcloser = 0
	}
	local.skillbonus = level.jvbot_skill * 25 - 50	
	local.aimtimebonus = (3 - (level.jvbot_skill - 1)) / 3.0 + 0.33
	
	switch(self.weapon)
	{
		case 1:
		case 2:
			self.dodgepct = 25
			self.aggresiveness = 25
			self.backawaypct = 25
			self.strafepct = 75
			self.shootpct = 100
			self.aimdodge = 1
			self.aimtime = 0.25 * local.aimtimebonus
			self.accuracy = 80 + local.skillbonus
			break
		case 3:
		case 4:
			self.dodgepct = 15
			self.aggresiveness = 0
			self.backawaypct = 50
			self.strafepct = 75
			self.shootpct = 100
			self.aimdodge = 1
			self.aimtime = 0.7 * local.aimtimebonus
			self.accuracy = 90 + local.skillbonus
			break
		case 5:
		case 6:
			self.dodgepct = 50
			self.aggresiveness = 50
			self.backawaypct = 0
			self.strafepct = 100
			self.shootpct = 100
			self.aimdodge = 1
			self.aimtime = 0.10 * local.aimtimebonus
			self.accuracy = 40 + local.skillbonus
			self.movecloser = 1
			break
		case 7:
			self.dodgepct = 50
			self.aggresiveness = 25
			self.backawaypct = 25
			self.strafepct = 25
			self.shootpct = 100
			self.aimdodge = 1
			self.aimtime = 0.20 * local.aimtimebonus
			self.accuracy = 50 + local.skillbonus
			break
		case 8:
			self.dodgepct = 30
			self.aggresiveness = 40
			self.backawaypct = 15
			self.strafepct = 50
			self.shootpct = 100
			self.aimdodge = 1
			self.aimtime = 0.15 * local.aimtimebonus
			self.accuracy = 60 + local.skillbonus
			self.movecloser = 1
			break
		case 9:
			self.dodgepct = 25
			self.aggresiveness = 90
			self.backawaypct = 0
			self.strafepct = 50
			self.shootpct = 100
			self.aimdodge = 1
			self.aimtime = 0.10 * local.aimtimebonus
			self.accuracy = 30 + local.skillbonus
			self.movecloser = 1
			break
		default:
			self.dodgepct = 50
			self.aggresiveness = 50
			self.backawaypct = 50
			self.strafepct = 50
			self.shootpct = 100
			self.aimdodge = 1
			self.aimtime = 0.25 * local.aimtimebonus
			self.accuracy = 50 + local.skillbonus
	}
	
	thread AttackMediumRange
	local.mythread = parm.previousthread

	self.instandshoot = 0
	self.movedtointervaldir = 0
	self.movingtointervaldir = 0
	self.inreload = 0

	while(1)
	{
		local.distance = self.distancetoenemy
		if ((local.distance > self.mediumrange || local.distance < self.shortrange) && self.inreload == 0 && self.movingtointervaldir == 0)
		{
			break
		}

		if (self.instandshoot==1 && self.inreload == 0 && self.movingtointervaldir == 0)
		{
			waitexec anim/jv_bots/attack.scr::AttackIsEnemyAimingAtMe

			if (self.enemyaimingme > 0)
			{
// TODO (Boon) Perhaps play panic face here?
				waitexec anim/jv_bots/attack.scr::AttackCheckLeft self.dist_walkleft
				if (self.collideresult == 0)
				{
					waitexec anim/jv_bots/attack.scr::AttackCheckRight self.dist_walkright
				}

				if (self.collideresult > 0)
				{
					thread DPrintln "calling dodge"
					self.instandshoot = 0
					
					local.mythread delete
					waitexec anim/jv_bots/attack.scr::AttackDeleteSubThread
					
					waitexec anim/jv_bots/attack.scr::AttackStandDodge
					thread AttackMediumRange
					local.mythread = parm.previousthread
				}
			}
		}

		waitframe
	}

	local.mythread delete
	waitexec anim/jv_bots/attack.scr::AttackDeleteSubThread
	//group delete
end

//=============================================================
//=============================================================
AttackLongRangeStart:
	local.skillbonus = level.jvbot_skill * 25 - 50
	local.aimtimebonus = (3 - (level.jvbot_skill - 1)) / 3.0 + 0.33
		
	switch(self.weapon)
	{
		case 1:
		case 2:
			self.dodgepct = 25
			self.aggresiveness = 10
			self.backawaypct = 50
			self.strafepct = 50
			self.shootpct = 100
			self.aimdodge = 1
			self.aimtime = 0.50 * local.aimtimebonus
			self.accuracy = 50 + local.skillbonus
			break
		case 3:
		case 4:
			self.dodgepct = 10
			self.aggresiveness = 0
			self.backawaypct = 50
			self.strafepct = 75
			self.shootpct = 100
			self.aimdodge = 1
			self.aimtime = 1.2 * local.aimtimebonus
			self.accuracy = 80 + local.skillbonus
			break
		case 5:
		case 6:
			self.dodgepct = 25
			self.aggresiveness = 90
			self.backawaypct = 0
			self.strafepct = 50
			self.shootpct = 100
			self.aimdodge = 1
			self.aimtime = 0.40 * local.aimtimebonus
			self.accuracy = 20 + local.skillbonus
			self.movecloser = 1
			break
		case 7:
			self.dodgepct = 25
			self.aggresiveness = 25
			self.backawaypct = 25
			self.strafepct = 50
			self.shootpct = 100
			self.aimdodge = 1
			self.aimtime = 0.50 * local.aimtimebonus
			self.accuracy = 40 + local.skillbonus
			break
		case 8:
			self.dodgepct = 25
			self.aggresiveness = 75
			self.backawaypct = 25
			self.strafepct = 50
			self.shootpct = 100
			self.aimdodge = 1
			self.aimtime = 0.30 * local.aimtimebonus
			self.accuracy = 60 + local.skillbonus
			self.movecloser = 1
			break
		case 9:
			self.dodgepct = 25
			self.aggresiveness = 100
			self.backawaypct = 0
			self.strafepct = 50
			self.shootpct = 100
			self.aimdodge = 1
			self.aimtime = 0.20 * local.aimtimebonus
			self.accuracy = 10 + local.skillbonus
			self.movecloser = 1
			break
		default:
			self.dodgepct = 50
			self.aggresiveness = 70
			self.backawaypct = 20
			self.strafepct = 50
			self.shootpct = 100
			self.aimdodge = 1
			self.aimtime = 0.40 * local.aimtimebonus
			self.accuracy = 50 + local.skillbonus
	}

	thread DPrintln "long range"

	if(self.movecloser == 1 && self.movingcloser != 1)
	{
		// run towards enemy
		self tether self.enemy
		self.movingcloser = 1
	}
	
	self.instandshoot = 0
	self.movedtointervaldir = 0
	self.movingtointervaldir = 0
	self.inreload = 0

	thread AttackLongRange
	local.mythread = parm.previousthread

	while(1)
	{
		local.distance = self.distancetoenemy
		if (local.distance < self.mediumrange && self.inreload == 0 && self.movingtointervaldir == 0)
		{
			break
		}

		waitframe
	}

	local.mythread delete
	waitexec anim/jv_bots/attack.scr::AttackDeleteSubThread
end

//=============================================================
//=============================================================
AttackReallyShortRange:
	//println ":: call: attackreallyshortrange"
	local.distance = self.distancetoenemy
	self.accuracy = 100
	self weaponcommand mainhand attachtohand mainhand
	self setmotionanim (self.weapongroup + "_stand_alert_legs")
	// Note: local.distance returns 0 if I don't have an enemy
	while ( (local.distance > 0 ) && (local.distance < self.reallyshortrange) )
	{
		waitexec anim/jv_bots/attack.scr::AttackDoMelee
		local.distance = self.distancetoenemy
		self.lastmovement = "stand"
		self interrupt_point
	}
end

//=============================================================
//=============================================================
AttackDoMelee:
	//println ":: call: attackdomelee"
	self.blendtime = 0.25
	//self thread anim/SayManager.scr::SayManager face_hit 5
	
	self playsound rifle_whip
	self setupperanim (self.weapongroup + "_butt")
	wait 0.38
// can't make AI unkillable this way		self.enemy normal_damage 25
	if(self.distancetoenemy <= self.reallyshortrange)
	{
		if ( self . enemy != $player )
			self.enemy damage self 25 self (0 0 0) (0 0 0) (0 0 0) 1 9 0 0 // dmg was 75
		else
		{
			local . dir = $player . origin - self . origin;
			self.enemy damage self 25 self (0 0 0) local . dir (0 0 0) 1 9 0 0 // dmg was 75
		}
	}
	self playsound rifle_hit
	self waittill upperanimdone
end

//=============================================================
//=============================================================
AttackMediumRange:
	thread DPrintln "calling attack medium range"
	switch (self.weapongroup)
	{
		rifle:
		mp40:
		mp44:
		bar:
		thompson:
		pistol:
		bazooka:
		shotgun:
			waitexec anim/jv_bots/attack.scr::AttackStandUp
			while (1)
			{
				waitexec anim/jv_bots/attack.scr::AttackStandMoveToIntervalDir
				waitexec anim/jv_bots/attack.scr::AttackStandDodge
				//waitexec anim/jv_bots/attack.scr::AttackStand
			}
			break

		grenade:
		mg42:
		generic:
		unarmed:
		handler:
		dog:
		default:
			println ("^~^~^ Attack medium range default case for "+self.weapongroup+" weapon group - fix attack.scr")
			break
	}
end

//=============================================================
//=============================================================
AttackStand:
	//println ":: call: attackstand"
	if (self.needreload == 1)
	{
		waitexec anim/reload.scr::Reload 0
	}
	else
	{
		self.playedreloadanim = 0
		self.playedrechamberanim = 0
	}


	self.instandshoot = 1
	self weaponcommand mainhand attachtohand mainhand

	waitexec anim/shoot.scr::CanShoot

	if (self.canshoot == 1)
	{
		if (self.lastmovement != stand)
		{
			self.blendtime = 0.20
			//self thread anim/SayManager.scr::SayManager face_aiming 3
			self setmotionanim (self.weapongroup + "_stand_alert_legs")
			//self setactionanim (self.weapongroup + "_aim") -60 60
			waitexec anim/aim.scr::PlayAimActionAnim
			wait self.aimtime
		}

		waitexec anim/shoot.scr::CanShoot

		if(self.enemy.weapon == "springfield '03 sniper" || self.enemy.weapon == "mauser kar 98d sniper")
		{
			if(randomfloat 100 < 5)
				self thread global/jv_bots/jv_mp_ai.scr::say cd // sniper!
		}

		if (self.canshoot == 1)
		{
			//self.blendtime = 0.05
			//self thread anim/SayManager.scr::SayManager face_attack 5
			
			self setmotionanim (self.weapongroup + "_stand_alert_legs")
			//self setactionanim (self.weapongroup + "_shoot") -60 60
			waitexec anim/shoot.scr::PlayShootActionAnim
			self waittill upperanimdone
			//self.shootdone = 1
			self.needreload = 1
			//so that we don't get interrupted
			self.instandshoot = 0
			waitexec anim/reload.scr::Reload 1 0
		}
		else
		{
			//println "~^~^~^AttackStand can't shoot after aim!"
			//self lightradius 512
			if (self.lastmovement == stand)
			{
				//just aim if we can't shoot
				self.blendtime = 0.20
				//self thread anim/SayManager.scr::SayManager face_aiming 3
				self setmotionanim (self.weapongroup + "_stand_alert_legs")
				//self setactionanim (self.weapongroup + "_aim") -60 60
				waitexec anim/aim.scr::PlayAimActionAnim
				wait self.aimtime
			}
			else
			{
				//wait a frame here so that we don't do multiple sight trace
				//in one frame
				waitexec anim/aim.scr::PlayAimActionAnim
				waitframe
			}
			//self lightradius 64
		}
		
		self.lastmovement = "stand"
	}
	else
	{
		//println "~^~^~^AttackStand can't shoot!"
		//self lightradius 512
		self.needreload = 0
		self.instandshoot = 0
		self.blendtime = 0.30
		self endactionanim
		self setupperanim (self.weapongroup + "_stand_alert")
		self setmotionanim (self.weapongroup + "_stand_alert_legs")
		self.lastmovement = "stand_alert"
		wait self.blendtime
		//self lightradius 64
	}

	self.instandshoot = 0
	self interrupt_point
end

//=============================================================
//=============================================================
AttackStandAndAim:
	//println ":: call: attackstandandaim"
	if (self.needreload == 1)
	{
		waitexec anim/reload.scr::Reload 0
	}
	else
	{
		self.playedreloadanim = 0
		self.playedrechamberanim = 0
	}

	self weaponcommand mainhand attachtohand mainhand
	self.blendtime = 0.30
	self setmotionanim (self.weapongroup + "_stand_alert_legs")

	waitexec anim/shoot.scr::CanShoot
	if (self.canshoot)
	{
		//self setactionanim (self.weapongroup + "_aim") -60 60
		waitexec anim/aim.scr::PlayAimActionAnim
		self.lastmovement = "stand"
	}
	else
	{
		//println "~^~^~^AttackStandAndAim can't shoot!"
		self.lastmovement = "stand_alert"
		self setupperanim (self.weapongroup + "_stand_alert")
	}

	wait self.blendtime
	self interrupt_point
end

//=============================================================
//=============================================================
AttackStandDodge:
	//println ":: call: attackstanddodge"
	//thread DPrintln self.intervaldir

	self.instandshoot = 0
	local.randnum = randomint 100
	waitexec anim/jv_bots/attack.scr::AttackIsEnemyAimingAtMe

	if (local.randnum < self.dodgepct || self.enemyaimingme > 0)
	{
// TODO (Boon) Perhaps play panic face here?
		//dodge left or right
		local.randnum = randomint 100

		if (local.randnum < 50)
		{
			//strafe left or hop left
			local.randnum = randomint 100

			if (local.randnum < self.strafepct)
			{
				waitexec anim/jv_bots/attack.scr::AttackDodgeStrafeLeft 1
			}
			else
			{
				waitexec anim/jv_bots/attack.scr::AttackDodgeLeft 1
			}
		}
		else
		{
			//strafe right or dodge right
			local.randnum = randomint 100

			if (local.randnum < self.strafepct)
			{
				waitexec anim/jv_bots/attack.scr::AttackDodgeStrafeRight 1
			}
			else
			{
				waitexec anim/jv_bots/attack.scr::AttackDodgeRight 1
			}
		}
	}
	else
	{
		local.randnum = randomint 100
		if (local.randnum < self.aggresiveness)
		{

			waitexec anim/jv_bots/attack.scr::AttackCheckFront self.dist_walkforward
			if (self.collideresult > 0)
			{
				self.blendtime = 0.25

				self.lastmovement = "walk_forward"
				waitexec anim/jv_bots/attack.scr::AttackShootInMotion (self.weapongroup + "_walk_alert_forward") 1

				self interrupt_point
			}
			else
			{
				waitexec anim/jv_bots/attack.scr::AttackStand
			}
		}
		else
		{
			local.randnum = randomint 100
			if (local.randnum < self.backawaypct)
			{
				waitexec anim/jv_bots/attack.scr::AttackCheckBack self.dist_walkbackward
				if (self.collideresult > 0)
				{
					self.blendtime = 0.25

					self.lastmovement = "walk_backward"
					waitexec anim/jv_bots/attack.scr::AttackShootInMotion (self.weapongroup + "_walk_alert_back") 2

					self interrupt_point
				}
				else
				{
					waitexec anim/jv_bots/attack.scr::AttackStand
				}
			}
			else
			{
				waitexec anim/jv_bots/attack.scr::AttackStand
			}
		}
	}
end

//=============================================================
//=============================================================
AttackDodgeLeft local.oppositedodge:
	//println ":: call: attackdodgeleft"
	waitexec anim/jv_bots/attack.scr::AttackCheckLeft self.dist_dodgeleft
	if (self.collideresult > 0)
	{
		self.blendtime = 0.25

		self.lastmovement = "dodge_left"
		
		waitexec anim/jv_bots/attack.scr::AttackShootInMotion (self.weapongroup + "_stand_dodge_left") 3

		if (self.needreload == 1)
		{
			waitexec anim/reload.scr::Reload 0
		}

		self interrupt_point

		//if (self.weapongroup == bazooka && self.playedreloadanim == 0)
		if (self.weapongroup == bazooka)
		{
			waitexec anim/jv_bots/attack.scr::AttackStand
		}
	}
	else
	{
		if (local.oppositedodge > 0)
		{
			//wait a frame so that we don't do multiple trace checks
			waitframe
			waitexec anim/jv_bots/attack.scr::AttackDodgeRight 0
		}
		else
		{
			waitexec anim/jv_bots/attack.scr::AttackStand
		}
	}
end

//=============================================================
//=============================================================
AttackDodgeRight local.oppositedodge:
	//println ":: call: attackdodgeright"
	waitexec anim/jv_bots/attack.scr::AttackCheckRight self.dist_dodgeright
	if (self.collideresult > 0)
	{
		self.blendtime = 0.25

		self.lastmovement = "dodge_right"
		
		waitexec anim/jv_bots/attack.scr::AttackShootInMotion (self.weapongroup + "_stand_dodge_right") 4

		if (self.needreload == 1)
		{
			waitexec anim/reload.scr::Reload 0
		}

		self interrupt_point

		//if (self.weapongroup == bazooka && self.playedreloadanim == 0)
		if (self.weapongroup == bazooka)
		{
			waitexec anim/jv_bots/attack.scr::AttackStand
		}
	}
	else
	{
		if (local.oppositedodge)
		{
			//wait a frame so that we don't do multiple trace checks
			waitframe
			waitexec anim/jv_bots/attack.scr::AttackDodgeLeft 0
		}
		else
		{
			waitexec anim/jv_bots/attack.scr::AttackStand
		}
	}
end

//=============================================================
//=============================================================
AttackDodgeStrafeRight local.oppositestrafe:
	//println ":: call: attackdodgestraferight"
	if (self.weapongroup == pistol || self.weapongroup == rifle)
	{
		//local.i = randomint(1) + 1
		local.i = 1
	}
	else
	{
		local.i = randomint(4) + 1
	}

	local.j = local.i

	while (local.i > 0)
	{
		waitexec anim/jv_bots/attack.scr::AttackCheckRight self.dist_walkright
		if (self.collideresult > 0)
		{
			if (self.lastmovement == strafe_left && self.playedreloadanim == 0)
			{
				//stop first if we strafe right last time around so that the feet won't look funny
				thread DPrintln "Standing first before strafing right"
				waitexec anim/jv_bots/attack.scr::AttackStandAndAim
			}


			self.blendtime = 0.25

			self.lastmovement = "strafe_right"
			
			waitexec anim/jv_bots/attack.scr::AttackShootInMotion (self.weapongroup + "_walk_alert_right") 5

			self interrupt_point

			//if (self.weapongroup == bazooka && self.playedreloadanim == 0)
			if (self.weapongroup == bazooka)
			{
				waitexec anim/jv_bots/attack.scr::AttackStand
			}
		}
		else
		{
			//only strafe the other way if it's the first time
			if (local.i == local.j && local.oppositestrafe == 1)
			{
				thread DPrintln "Strafing the other way to left"
				//wait a frame so that we don't do multiple trace checks
				waitframe
				waitexec anim/jv_bots/attack.scr::AttackDodgeStrafeLeft 0
			}
			else
			{
				waitexec anim/jv_bots/attack.scr::AttackStand
			}

			break
		}

		local.i = local.i - 1
	}
end

//=============================================================
//=============================================================
AttackDodgeStrafeLeft local.oppositestrafe:
	//println ":: call: attackdodgestrafeleft"
	if (self.weapongroup == pistol || self.weapongroup == rifle)
	{
		//local.i = randomint(1) + 1
		local.i = 1
	}
	else
	{
		local.i = randomint(4) + 1
	}

	local.j = local.i

	while (local.i > 0)
	{
		waitexec anim/jv_bots/attack.scr::AttackCheckLeft self.dist_walkleft
		if (self.collideresult > 0)
		{
			if (self.lastmovement == strafe_right && self.playedreloadanim == 0)
			{
				//stop first if we strafe right last time around so that the feet won't look funny
				thread DPrintln "Standing first before strafing left"
				waitexec anim/jv_bots/attack.scr::AttackStandAndAim
			}

			self.blendtime = 0.25

			self.lastmovement = "strafe_left"
			
			waitexec anim/jv_bots/attack.scr::AttackShootInMotion (self.weapongroup + "_walk_alert_left") 6


			self interrupt_point

			//if (self.weapongroup == bazooka && self.playedreloadanim == 0)
			if (self.weapongroup == bazooka)
			{
				waitexec anim/jv_bots/attack.scr::AttackStand
			}

		}
		else
		{
			//only strafe the other way if it's the first time
			if (local.i == local.j && local.oppositestrafe == 1)
			{
				thread DPrintln "Strafing the other way to Right"
				//wait a frame so that we don't do multiple trace checks
				waitframe
				waitexec anim/jv_bots/attack.scr::AttackDodgeStrafeRight 0
			}
			else
			{
				waitexec anim/jv_bots/attack.scr::AttackStand
			}
			break
		}

		local.i = local.i - 1
	}
end

//=============================================================
//=============================================================
AttackShootInMotion local.animname local.id:
	//println ":: call: attackshootinmotion"
	self weaponcommand mainhand attachtohand mainhand

	if (self.needreload == 1)
	{
		waitexec anim/reload.scr::Reload 2
	}
	else
	{
		self.playedreloadanim = 0
		self.playedrechamberanim = 0
	}

	self weaponcommand mainhand attachtohand mainhand

	local.randnum = randomint 100
	if (local.randnum < self.shootpct && (self cansee self.enemy))
	{
		thread DPrintln "(Boon) Fired without aiming " local.id " - did anything weird happen?"
		//self thread anim/SayManager.scr::SayManager face_attack 5

		//waitexec anim/shoot.scr::PlayShootActionAnim
		//self setmotionanim local.animname
		//self waittill flaggedanimdone
		//self waittill upperanimdone
		//self.needreload = 1

		switch (self.weapon)
		{
			case "springfield '03 sniper":
			case "mauser kar 98k":
			case "mauser kar 98d sniper":
				//waitexec anim/shoot.scr::PlayShootActionAnim
				//self setmotionanim local.animname
				//self waittill flaggedanimdone
				//self waittill upperanimdone
				//self.needreload = 1
				
				thread AttackShootInMotionThread
				self setmotionanim local.animname
				self waittill flaggedanimdone
				self.needreload = 1

				while (self.shootinmotionanimdone == 0)
				{
					waitframe
				}
				waitexec anim/jv_bots/attack.scr::AttackDeleteSubThread
				break
			
			default:
				//waitexec anim/shoot.scr::PlayShootActionAnim
				//self setmotionanim local.animname
				//self waittill flaggedanimdone
				//self.needreload = 1
				
				thread AttackShootInMotionThread
				self setmotionanim local.animname
				self waittill flaggedanimdone
				self.needreload = 1
				waitexec anim/jv_bots/attack.scr::AttackDeleteSubThread
				//waitexec anim/aim.scr::PlayAimActionAnim
				break
		}

	}
	else
	{
		//self thread anim/SayManager.scr::SayManager face_aiming 3
		self.needreload = 0
		//self setactionanim (self.weapongroup + "_aim") -60 60
		waitexec anim/aim.scr::PlayAimActionAnim
		self setmotionanim local.animname
		self waittill flaggedanimdone
	}
end

//=============================================================
//=============================================================
AttackShootInMotionThread:
	//println ":: call: attackshootinmotionthread"
	/*
	group.subthread = local
	self.shootinmotionanimdone = 0
	waitexec anim/shoot.scr::PlayShootActionAnim
	self waittill upperanimdone
	self.shootinmotionanimdone = 1
	waitexec anim/aim.scr::PlayAimActionAnim
	self waittill upperanimdone
	*/
	
	group.subthread = local
	self.shootinmotionanimdone = 0
	waitexec anim/aim.scr::PlayAimActionAnim
	self waittill upperanimdone
	waitexec anim/shoot.scr::PlayShootActionAnim
	self waittill upperanimdone
	self.shootinmotionanimdone = 1
end

//=============================================================
//=============================================================
AttackLongRange:
	//println ":: call: attacklongrange"
	switch (self.weapongroup)
	{
		rifle:
		mp40:
		mp44:
		bar:
		thompson:
		pistol:
		bazooka:
			while (1)
			{
				waitexec anim/jv_bots/attack.scr::AttackStandMoveToIntervalDir

				local.noprone = 0
				local.distance = self.distancetoenemy
				if (local.distance >= self.pronedistance && self.weapongroup != bazooka && self.team == german)
				{
					self.collideresult = 0
					if (self.position != prone)
					{
						waitexec anim/jv_bots/attack.scr::AttackCheckProne
					}

					if (self.collideresult > 0 || self.position == prone)
					{
						waitexec anim/jv_bots/attack.scr::AttackProneDown
						//if ((self cansee self.enemy) > 0)
						//{
							waitexec anim/jv_bots/attack.scr::AttackLongRangeProne
						//}
						//else
						//{
						//	local.noprone = 1
						//}
					}
					else
					{
						local.noprone = 1
					}
				}
				else
				{
					local.noprone = 1
				}

				local.nocrouch = 0

				if (local.distance < self.pronedistance || local.noprone == 1)
				{
					self.collideresult = 0
					if (self.position != crouch)
					{
						waitexec anim/jv_bots/attack.scr::AttackCheckCrouch
					}

					if (self.collideresult > 0 || self.position == crouch)
					{
						waitexec anim/jv_bots/attack.scr::AttackCrouchDown
						//if ((self cansee self.enemy) > 0)
						//{
							waitexec anim/jv_bots/attack.scr::AttackLongRangeCrouch
						//}
						//else
						//{
						//	local.nocrouch = 1
						//}
					}
					else
					{
						local.nocrouch = 1
					}
				}
				else
				{
					local.nocrouch = 1
				}


				if (local.noprone == 1 && local.nocrouch == 1)
				{
					//can't crouch or prone.. so let's just stand
					waitexec anim/jv_bots/attack.scr::AttackStandUp
					waitexec anim/jv_bots/attack.scr::AttackLongRangeStand
				}
			}
			break

		grenade:
		mg42:
		generic:
		unarmed:
		handler:
		dog:
		default:
			println ("^~^~^ Attack medium range default case for "+self.weapongroup+" weapon group - fix attack.scr")
			break
	}
end


//=============================================================
//=============================================================
AttackLongRangeStand:
	//println ":: call: attacklongrangestand"
	waitexec anim/jv_bots/attack.scr::AttackStandMoveToIntervalDir
	waitexec anim/jv_bots/attack.scr::AttackStandDodge
	//waitexec anim/jv_bots/attack.scr::AttackStand
end

//=============================================================
//=============================================================
AttackLongRangeCrouch:
	//println ":: call: attacklongrangecrouch"
	waitexec anim/jv_bots/attack.scr::AttackCrouchDodge
	waitexec anim/jv_bots/attack.scr::AttackCrouch
end

//=============================================================
//=============================================================
AttackLongRangeProne:
	//println ":: call: attacklongrangeprone"
	waitexec anim/jv_bots/attack.scr::AttackProneDodge
	waitexec anim/jv_bots/attack.scr::AttackProne
end

//=============================================================
//=============================================================
AttackCrouch:
	//println ":: call: attackcrouch"
	if (self.weapongroup == bazooka)
	{
		waitexec anim/jv_bots/attack.scr::AttackCrouchBazooka
	}
	else
	{
		self setmotionanim (self.weapongroup + "_crouch_alert")

		if (self.needreload == 1)
		{
			waitexec anim/reload.scr::Reload 1
		}
		else
		{
			self.playedreloadanim = 0
			self.playedrechamberanim = 0
		}

		self weaponcommand mainhand attachtohand mainhand

		if (self.lastmovement != crouch)
		{
			//aim till we're ready to fire
			self.blendtime = 0.20
			//self thread anim/SayManager.scr::SayManager face_aiming 3
			//self setmotionanim (idle_crouch_rifle)
			self setactionanim (self.weapongroup + "_aim") -60 60
			//self waittill flaggedanimdone
			wait self.aimtime
		}


		if ((self cansee self.enemy) > 0)
		{
			self.blendtime = 0.05
			//self thread anim/SayManager.scr::SayManager face_attack 5
			switch (self.weapon)
			{
				case "springfield '03 sniper":
				case "mauser kar 98k":
				case "mauser kar 98d sniper":
					self setactionanim kar98_shoot -60 60
					self waittill upperanimdone
					self.needreload = 1
					//so that we don't get interrupted
					self.instandshoot = 0
					waitexec anim/reload.scr::Reload 1 1
					break
				default:
					self setactionanim (self.weapongroup + "_shoot") -60 60
					self waittill upperanimdone
					self.needreload = 1
					//so that we don't get interrupted
					self.instandshoot = 0
					waitexec anim/reload.scr::Reload 1 0
					break
			}
		}
		else if (self.lastmovement == crouch)
		{
			//Just aim if we can't shoot and did not aim from above
			self.blendtime = 0.20
			//self thread anim/SayManager.scr::SayManager face_aiming 3
			//self setmotionanim (idle_crouch_rifle)
			self setactionanim (self.weapongroup + "_aim") -60 60
//			self waittill upperanimdone
			wait self.aimtime
		}

		self.lastmovement = "crouch"
		self interrupt_point
	}
end

//=============================================================
//=============================================================
AttackCrouchBazooka:
	//println ":: call: attackcrouchbazooka"
	self setmotionanim (self.weapongroup + "_crouch_alert")

	if (self.needreload == 1)
	{
		waitexec anim/reload.scr::Reload 1
	}
	else
	{
		self.playedreloadanim = 0
		self.playedrechamberanim = 0
	}

	self weaponcommand mainhand attachtohand mainhand

	//aim till we're ready to fire
	local.i = 1
	while (!(self ReadyToFire) || local.i > 0)
	{
		self.blendtime = 0.30
		//self thread anim/SayManager.scr::SayManager face_aiming 3
		self setactionanim (self.weapongroup + "_aim") -60 60
//		self waittill upperanimdone
		wait self.aimtime

		local.i = local.i - 1
	}

	self.lastmovement = "crouch"

	if ((self cansee self.enemy) > 0)
	{
		self.blendtime = 0.1
		//self thread anim/SayManager.scr::SayManager face_attack 5
		self setactionanim (self.weapongroup + "_shoot") -60 60
		self waittill upperanimdone
		//so that we don't get interrupted
		self.instandshoot = 0
		waitexec anim/reload.scr::Reload 1
	}

	self interrupt_point
end

//=============================================================
//=============================================================
AttackProne:
	//println ":: call: attackprone"
	self.position = prone
	if (self.needreload == 1)
	{
		waitexec anim/reload.scr::Reload 0
	}
	else
	{
		self.playedreloadanim = 0
		self.playedrechamberanim = 0
	}

	self weaponcommand mainhand attachtohand mainhand

	//aim till we're ready to fire
	local.i = 1
	//while (!(self ReadyToFire) || local.i > 0)
	while (local.i > 0)
	{
		self.blendtime = 0.20
		//self thread anim/SayManager.scr::SayManager face_aiming 3
		self setmotionanim (self.weapongroup + "_prone_legs")
		self setactionanim (self.weapongroup + "_prone_aim") -60 60
//		self waittill flaggedanimdone
		wait self.aimtime

		local.i = local.i - 1
	}

	self.lastmovement = "prone"

	if ((self cansee self.enemy) > 0)
	{
		self.blendtime = 0.1
		//self thread anim/SayManager.scr::SayManager face_attack 5
		self setmotionanim (self.weapongroup + "_prone_legs")
		self setactionanim (self.weapongroup + "_prone_shoot") -60 60
		self waittill upperanimdone

		// Simulate rechamber since we don't have an animation for it
		if ( (self.weapon == "springfield '03 sniper") || (self.weapon == "mauser kar 98k") || (self.weapon == "mauser kar 98d sniper") )
		{
			self setactionanim (self.weapongroup + "_prone_aim") -60 60
			wait 0.4
		}

		self.needreload = 0
		//so that we don't get interrupted
		self.instandshoot = 0
		//per Boon--no reload during prone
		//waitexec anim/reload.scr::Reload 0
	}

	self interrupt_point
end

//=============================================================
//=============================================================
AttackCrouchDodge:
	//println ":: call: attackcrouchdodge"
	local.randnum = randomint 100
	waitexec anim/jv_bots/attack.scr::AttackIsEnemyAimingAtMe

	if (local.randnum < self.dodgepct || self.enemyaimingme > 0)
	{
// TODO (Boon) Perhaps play panic face here?
		self weaponcommand mainhand attachtohand mainhand

		local.randnum = randomint 100
		
		if(self.enemy.weapon == "springfield '03 sniper" || self.enemy.weapon == "mauser kar 98d sniper")
		{
			if(randomfloat 100 < 30)
				self thread global/jv_bots/jv_mp_ai.scr::say cd // sniper!
		}
		
		if (local.randnum < 50)
		{
			waitexec anim/jv_bots/attack.scr::AttackCheckLeft self.dist_crouchleft
			if (self.collideresult > 0)
			{
				self.blendtime = 0.5
				//self thread anim/SayManager.scr::SayManager face_aiming 3
				self setmotionanim (walk_crouch_left)
				self setactionanim (self.weapongroup + "_aim") -60 60
				self waittill flaggedanimdone
				self.lastmovement = "crouch_left"
			}
		}
		else
		{
			waitexec anim/jv_bots/attack.scr::AttackCheckRight self.dist_crouchright
			if (self.collideresult > 0)
			{
				self.blendtime = 0.5
				//self thread anim/SayManager.scr::SayManager face_aiming 3
				self setmotionanim (walk_crouch_right)
				self setactionanim (self.weapongroup + "_aim") -60 60
				self waittill flaggedanimdone
				self.lastmovement = "crouch_right"
			}
		}
	}
end

//=============================================================
//=============================================================
AttackProneDodge:
	//println ":: call: attackpronedodge"
	local.randnum = randomint 100
//	waitexec anim/jv_bots/attack.scr::AttackIsEnemyAimingAtMe

//	if (local.randnum < self.dodgepct || self.enemyaimingme > 0)
	if (local.randnum < self.dodgepct)
	{
		self weaponcommand mainhand attachtohand mainhand

		local.randnum = randomint 100

		if (local.randnum < 50)
		{
			waitexec anim/jv_bots/attack.scr::AttackCheckLeft self.dist_prone_roll_left
			if (self.collideresult > 0)
			{
				self.blendtime = 0.3
				self setmotionanim (self.weapongroup + "_prone_roll_left")
				self waittill flaggedanimdone
				self.lastmovement = "prone_roll_left"
			}
		}
		else
		{
			waitexec anim/jv_bots/attack.scr::AttackCheckRight self.dist_prone_roll_right
			if (self.collideresult > 0)
			{
				self.blendtime = 0.3
				self setmotionanim (self.weapongroup + "_prone_roll_right")
				self waittill flaggedanimdone
				self.lastmovement = "prone_roll_right"
			}
		}
	}
end


//=============================================================
//=============================================================
AttackStandMoveToIntervalDir:
	//println ":: call: attackstandmovetointervaldir"
	self.movedtointervaldir = 0
	self.movingtointervaldir = 0

	if (self.intervaldir != (0 0 0))
	{
		thread DPrintln "Moving to interval dir: " self.intervaldir

		local.stoodup = 0
		local.spawnedshootthread = 0
		self weaponcommand mainhand attachtohand mainhand

		while (self.intervaldir != (0 0 0))
		{
			//check to see if we can move
			local.movepos = (self.intervaldir * 93) + self.origin
			self.collideresult = 0
			local.movetoresult = self canmoveto local.movepos
			if (local.movetoresult == 1)
			{
				self.collideresult = self sighttrace self.origin local.movepos 1 ( -16 -16 16) ( 16 16 96)
			}

			if (self.collideresult > 0)
			{
				// We're spreading out, so tell each other (trying to sound smarter...)
				/*
				if ( (level.nextsayspread == NULL) || (level.nextsayspread == NIL) || (level.time > level.nextsayspread) )
				{
					level.nextsayspread = level.time + ( (randomint 200 + 50) / 100 )
					
					if (self.team == "german")
					{
						self thread anim/SayManager.scr::SayManager ("den_head_spread_" + self.voicetype) 3
					}
					else
					{
						self thread anim/SayManager.scr::SayManager ("dfr_head_spread_" + self.voicetype) 3
					}
					
					local.randnum = randomint 2
					if(local.randnum == 0)
						self thread global/jv_bots/jv_mp_ai.scr::say ac // attack right flank
					else
						self thread global/jv_bots/jv_mp_ai.scr::say ad // attack left flank
				}*/

				self.movingtointervaldir = 1

				if (local.stoodup == 0)
				{
					waitexec anim/jv_bots/attack.scr::AttackStandUp
					local.stoodup = 1
				}

				if (local.spawnedshootthread == 0)
				{
					thread AttackStandMoveToIntervalDirShoot
					self.shootthread = parm.previousthread
					local.spawnedshootthread = 1
				}

				self.blendtime = 0.20

				local.dotvec = self.forwardvector * self.intervaldir
				local.sidevec = self.leftvector * self.intervaldir
				local.forwardbackblend = abs(local.dotvec)
				local.sideblend = 1.0 - local.forwardbackblend

				//sanity checks
				if (local.sideblend < 0.00)
				{
					local.sideblend = 0.00
				}

				if (local.sideblend > 1.0)
				{
					local.sideblend = 1.0
				}

				thread DPrintln "Forward: " local.forwardbackblend " Side: " local.sideblend

				if (local.dotvec >= 0.00)
				{
					//move forward
					self setanim (self.weapongroup + "_walk_alert_forward") 0 local.forwardbackblend

					if (local.dotvec >= 0.70)
					{
						self.lastmovement = "walk_forward"
					}
				}
				else
				{
					self setanim (self.weapongroup + "_walk_alert_back") 0 local.forwardbackblend

					if (local.dotvec <= -0.70)
					{
						self.lastmovement = "walk_backward"
					}
				}

				if (local.sidevec >= 0.00)
				{
					//move left
					self setanim (self.weapongroup + "_walk_alert_left") 1 local.sideblend
					if (local.dotvec < 0.70 && local.dotvec > -0.70)
					{
						self.lastmovement = "strafe_left"
					}
				}
				else
				{
					//move right
					self setanim (self.weapongroup + "_walk_alert_right") 1 local.sideblend
					if (local.dotvec < 0.70 && local.dotvec > -0.70)
					{
						self.lastmovement = "strafe_right"
					}
				}

				self.movedtointervaldir = 1
				wait 0.2
			}
			else
			{
				thread DPrintln "Could not move to interval dir!"
				break
			}
		}

		if (local.spawnedshootthread == 1)
		{
			self.shootthread delete
		}

		self.movingtointervaldir = 0
		thread DPrintln "Done!"
	}
end

//=============================================================
//=============================================================
AttackStandMoveToIntervalDirShoot:
	//println ":: call: attackstandmovetointervaldirshoot"
	while (1)
	{
		if (self.needreload == 1)
		{
			waitexec anim/reload.scr::Reload 1
		}
		else
		{
			self.playedreloadanim = 0
			self.playedrechamberanim = 0
		}

		local.randnum = randomint 100
		if (local.randnum < self.shootpct && (self cansee self.enemy))
		{
thread DPrintln "(Boon) Fired without aiming 7 - did anything weird happen?"
			//self thread anim/SayManager.scr::SayManager face_attack 5
			//self setactionanim (self.weapongroup + "_shoot") -60 60
			waitexec anim/shoot.scr::PlayShootActionAnim
			self.needreload = 1
			self waittill upperanimdone
		}
		else
		{
			//self thread anim/SayManager.scr::SayManager face_aiming 3
			waitexec anim/aim.scr::PlayAimActionAnim
			self.needreload = 0
			self waittill upperanimdone
		}

		if (self.movingtointervaldir == 0)
		{
			thread DPrintln "IntervalDirShoot thread is still running for " self
		}

		self interrupt_point
	}
end

//=============================================================
//=============================================================
//this is temporary until someone makes this a function call for the script
AttackIsEnemyAimingAtMe:
	//println ":: call: attackisenemyaimingatme"
	if (self.aimdodge == 1)
	{
		local.vec = (self.origin - self.enemy.origin)
		local.vec = vector_normalize (local.vec)
		local.dotvec = local.vec * self.enemy.forwardvector
		if (local.dotvec > 0.980)
		{
			self.enemyaimingme = 1
		}
		else
		{
			self.enemyaimingme = 0
		}
	}
	else
	{
		self.enemyaimingme = 0
	}
end

//=============================================================
//=============================================================
//Checks ahead to see if it's possible to crouch
AttackCheckCrouch:
	//println ":: call: attackcheckcrouch"
	local.start = self.origin
//	local.end = self.enemy.controid	//origin
	local.start[2] = local.start[2] + 45
//	local.end[2] = local.end[2] + 45
//	self.collideresult = self sighttrace local.start local.end 1
	self.collideresult = self canshootenemyfrom local.start
end

//=============================================================
//=============================================================
//Checks ahead to see if it's possible to go prone
AttackCheckProne:
	//println ":: call: attackcheckprone"
	//check height
	// jv's hack:
	/*
	local.height = self.enemy.origin[2] - self.origin[2]
	if (local.height < 160)
	{
		local.start = self.origin
		local.end = self.enemy.origin
		local.start[2] = local.start[2] + 22
		local.end[2] = local.end[2] + 22
		self.collideresult = self sighttrace local.start local.end 1
	}
	else
	{
		self.collideresult = 0
		println "~^~^ Can't prone - target is higher"
	}
	*/
	self.collideresult = 0
end

//=============================================================
//=============================================================
//Checks ahead to see if it's possible to move right without colliding
AttackCheckRight local.checkdist:
	//println ":: call: attackcheckright"
	local.movepos = (self.rightvector * local.checkdist) + self.origin
	self.collideresult = 0
	local.movetoresult = self canmoveto local.movepos
	if (local.movetoresult == 1)
	{
		self.collideresult = self sighttrace self.origin local.movepos 0 ( -16 -16 16) ( 16 16 128)
	}
	thread DPrintln "CheckRight got :" self.collideresult "Dist :" local.checkdist
end

//=============================================================
//=============================================================
//Checks ahead to see if it's possible to move left without colliding
AttackCheckLeft local.checkdist:
	//println ":: call: attackcheckleft"
	local.movepos = (self.leftvector * local.checkdist) + self.origin
	self.collideresult = 0
	local.movetoresult = self canmoveto local.movepos
	if (local.movetoresult == 1)
	{
		self.collideresult = self sighttrace self.origin local.movepos 0 ( -16 -16 16) ( 16 16 128)
	}
	thread DPrintln "CheckLeft got :" self.collideresult "Dist :" local.checkdist
end

//=============================================================
//=============================================================
//Checks ahead to see if it's possible to move forward without colliding
AttackCheckFront local.checkdist:
	//println ":: call: attackcheckfront"
	local.movepos = (self.forwardvector * local.checkdist) + self.origin
	self.collideresult = 0
	local.movetoresult = self canmoveto local.movepos
	if (local.movetoresult == 1)
	{
		self.collideresult = self sighttrace self.origin local.movepos 0 ( -16 -16 16) ( 16 16 128)
	}
	thread DPrintln "CheckFront got :" self.collideresult "Dist :" local.checkdist
end

//=============================================================
//=============================================================
//Checks ahead to see if it's possible to move backward without colliding
AttackCheckBack local.checkdist:
	//println ":: call: attackcheckback"
	local.tempvec = ( -self.forwardvector[0] -self.forwardvector[1] -self.forwardvector[2] )
	local.movepos = (local.tempvec * local.checkdist) + self.origin
	self.collideresult = 0
	local.movetoresult = self canmoveto local.movepos
	if (local.movetoresult == 1)
	{
		self.collideresult = self sighttrace self.origin local.movepos 0 ( -16 -16 16) ( 16 16 128)
	}
	thread DPrintln "CheckBack got :" self.collideresult "Dist :" local.checkdist
	thread DPrintln "Start: " self.origin "End : " local.movepos
end


//=============================================================
//called whenever the actor needs to stand
AttackStandUp:
	//println ":: call: attackstandup"
	switch (self.position)
	{
		pronewalk:
		prone:
			self.blendtime = 0.25
			self setmotionanim (self.weapongroup + "_pronetocrouch")
			self waittill flaggedanimdone

			self.position = crouch

		// *Deliberately drop through to the crouch case so we can stand from crouching*

		walk:
		run:
		stand:
		crouchwalk:
		crouchrun:
		crouch:
			self.blendtime = 0.50
			//self setactionanim (self.weapongroup + "_aim") -60 60
			waitexec anim/aim.scr::PlayAimActionAnim
			self setmotionanim (self.weapongroup + "_stand_alert_legs")
//			self waittill flaggedanimdone
			wait self.blendtime	// Time enough to stand up - not dependent on the length of the looping
								// animation stand_alert_legs, which could be any length.
			self.weaponpos = up
			self.position = stand
			break
		knees:
		crawl:
		floor:
		default:
			println ("^~^~^ Default case for position " + self.position + "in Attack.scr::AttackStandUp script")
			break
	}
end

//=============================================================
//called whenever the actor needs to crouch
AttackCrouchDown:
	//println ":: call: attackcrouchdown"
	switch (self.position)
	{
		walk:
		run:
		stand:
			self.blendtime = 0.50
			self setactionanim (self.weapongroup + "_aim") -60 60
			self setmotionanim (self.weapongroup + "_crouch_alert")
			// Let's set our state variables when we're halfway through blending, since we can.
			wait 0.25
			self.weaponpos = up
			self.position = crouch
			wait 0.25
			break
		crouchwalk:
		crouchrun:
		crouch:
			//already crouched
			self.position = crouch
			self.weaponpos = up
			break
		pronewalk:
		prone:
			self.blendtime = 0.25
			self setmotionanim (self.weapongroup + "_pronetocrouch")
			self waittill flaggedanimdone
			self.position = crouch
			self.weaponpos = up
			break
		knees:
		crawl:
		floor:
		default:
			println ("^~^~^ Default case for position " + self.position + "in Attack.scr::AttackCrouchDown script")
			break
	}
end

//=============================================================
//called whenever the actor needs to go to prone
AttackProneDown:
	//println ":: call: attackpronedown"
	switch (self.position)
	{
		walk:
		run:
		stand:
			self.blendtime = 0.50
			self setactionanim (self.weapongroup + "_aim") -60 60
			self setmotionanim (self.weapongroup + "_crouch_alert")
//			self waittill flaggedanimdone
			wait 0.5	// Time enough to crouch - not dependent on the length of the looping
						// animation <weapon>_crouch, which could be any length.

			self.position = crouch
			self.weaponpos = up

			self endactionanim
			self.blendtime = 0.30
			self setmotionanim (self.weapongroup + "_crouchtoprone")
			self waittill flaggedanimdone

			self.position = prone
			break

		crouchwalk:
		crouchrun:
		crouch:
			self endactionanim
			self.blendtime = 0.30
			self setmotionanim (self.weapongroup + "_crouchtoprone")
			self waittill flaggedanimdone
			self.position = prone
			self.weaponpos = up
			break
		pronewalk:
		prone:
			//already in prone
			self.position = prone
			break
		knees:
		crawl:
		floor:
		default:
			println ("^~^~^ Default case for position " + self.position + "in Attack.scr::AttackProneDown script")
			break
	}
end

//==================================================================
// thread DPrintln - for debug prints
DPrintln local.text1 local.text2 local.text3 local.text4 local.text5:
	if (level.boonDebug == 1)
	{
		if (local.text1 != NIL)
		{
			print local.text1
			if (local.text2 != NIL)
			{
				print local.text2
				if (local.text3 != NIL)
				{
					print local.text3
					if (local.text4 != NIL)
					{
						print local.text4
						if (local.text5 != NIL)
						{
							print local.text5
						}
					}
				}
			}
		}
		println
	}
end
